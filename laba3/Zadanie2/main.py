from abc import ABC, abstractmethod

# Абстракция: базовый класс Пицца
class Пицца(ABC):
    def __init__(self, название, тесто, соус, начинка, цена):
        self.__название = название
        self.__тесто = тесто
        self.__соус = соус
        self.__начинка = начинка
        self.__цена = float(цена)

    # Инкапсуляция: геттеры
    @property
    def название(self):
        return self.__название

    @property
    def цена(self):
        return self.__цена

    # Абстрактные методы
    @abstractmethod
    def подготовить(self):
        pass

    @abstractmethod
    def испечь(self):
        pass

    @abstractmethod
    def порезать(self):
        pass

    @abstractmethod
    def упаковать(self):
        pass

    # Полиморфизм: переопределение стандартных методов
    def __str__(self):
        return f"{self.__название} ({self.__цена} руб.)"

    def __eq__(self, other):
        if isinstance(other, Пицца):
            return self.__название == other.название and self.__цена == other.цена
        return False

# Наследование: конкретные виды пицц
class ПиццаПепперони(Пицца):
    def __init__(self):
        super().__init__("Пепперони", "Тонкое", "Томатный", ["пепперони", "моцарелла"], 500)

    def подготовить(self):
        return f"Готовим пиццу {self.название}: замешиваем {self._Пицца__тесто} тесто, добавляем соус {self._Пицца__соус} и начинку {self._Пицца__начинка}"

    def испечь(self):
        return f"Печём пиццу {self.название} при 220°C 10 минут"

    def порезать(self):
        return f"Режем пиццу {self.название} на 8 кусков"

    def упаковать(self):
        return f"Упаковываем пиццу {self.название} в коробку"

class ПиццаБарбекю(Пицца):
    def __init__(self):
        super().__init__("Барбекю", "Пышное", "Барбекю", ["курица", "лук", "сыр"], 550)

    def подготовить(self):
        return f"Готовим пиццу {self.название}: замешиваем {self._Пицца__тесто} тесто, добавляем соус {self._Пицца__соус} и начинку {self._Пицца__начинка}"

    def испечь(self):
        return f"Печём пиццу {self.название} при 200°C 12 минут"

    def порезать(self):
        return f"Режем пиццу {self.название} на 6 кусков"

    def упаковать(self):
        return f"Упаковываем пиццу {self.название} в коробку с логотипом"

class ПиццаДарыМоря(Пицца):
    def __init__(self):
        super().__init__("Дары Моря", "Тонкое", "Сливочный", ["креветки", "кальмары", "мидии"], 600)

    def подготовить(self):
        return f"Готовим пиццу {self.название}: замешиваем {self._Пицца__тесто} тесто, добавляем соус {self._Пицца__соус} и начинку {self._Пицца__начинка}"

    def испечь(self):
        return f"Печём пиццу {self.название} при 210°C 11 минут"

    def порезать(self):
        return f"Режем пиццу {self.название} на 8 кусков"

    def упаковать(self):
        return f"Упаковываем пиццу {self.название} в экологичную упаковку"

# Класс Заказ (Композиция: содержит список пицц)
class Заказ:
    def __init__(self):
        self.__заказ_пицц = []
        self.__статус_заказа = 0  # 0 - формируется, 1 - подтверждён, 2 - выполнен

    @property
    def статус_заказа(self):
        return self.__статус_заказа

    @property
    def стоимость(self):
        return sum(пицца.цена for пицца in self.__заказ_пицц)

    def добавить_пиццу(self, пицца):
        self.__заказ_пицц.append(пицца)

    def удалить_пиццу(self, индекс):
        if 0 <= индекс < len(self.__заказ_пицц):
            return self.__заказ_пицц.pop(индекс)
        raise IndexError("Неверный индекс пиццы")

    def выполнить(self):
        if self.__статус_заказа != 1:
            raise ValueError("Заказ не подтверждён")
        for пицца in self.__заказ_пицц:
            print(пицца.подготовить())
            print(пицца.испечь())
            print(пицца.порезать())
            print(пицца.упаковать())
        self.__статус_заказа = 2
        return "Заказ выполнен!"

    def __str__(self):
        пиццы = "\n".join(f"{i+1}. {пицца}" for i, пицца in enumerate(self.__заказ_пицц))
        return f"Заказ:\n{пиццы}\nИтого: {self.стоимость} руб."

# Класс Терминал
class Терминал:
    def __init__(self):
        self.__меню = [
            ПиццаПепперони(),
            ПиццаБарбекю(),
            ПиццаДарыМоря()
        ]
        self.__текущий_заказ = None

    def показать_меню(self):
        меню = "Меню:\n" + "\n".join(f"{i+1}. {пицца}" for i, пицца in enumerate(self.__меню))
        return меню

    def добавить_заказ(self):
        self.__текущий_заказ = Заказ()
        return "Новый заказ создан"

    def удалить_заказ(self):
        self.__текущий_заказ = None
        return "Заказ отменён"

    def оплатить(self):
        if not self.__текущий_заказ or self.__текущий_заказ.статус_заказа != 1:
            raise ValueError("Заказ не подтверждён")
        return f"Оплата {self.__текущий_заказ.стоимость} руб. принята"

    # Вызываемый метод
    def __call__(self, выбор):
        if not self.__текущий_заказ:
            raise ValueError("Сначала создайте заказ")
        выбор = int(выбор) - 1
        if 0 <= выбор < len(self.__меню):
            пицца = self.__меню[выбор]
            self.__текущий_заказ.добавить_пиццу(пицца)
            return f"Добавлена пицца: {пицца}"
        raise ValueError("Неверный выбор пиццы")

# Основная программа
def main():
    терминал = Терминал()
    print("Добро пожаловать в пиццерию!")
    
    while True:
        print("\n1. Показать меню")
        print("2. Создать заказ")
        print("3. Добавить пиццу в заказ")
        print("4. Показать текущий заказ")
        print("5. Подтвердить заказ")
        print("6. Оплатить заказ")
        print("7. Выполнить заказ")
        print("8. Отменить заказ")
        print("9. Выход")
        
        выбор = input("Выберите действие (1-9): ")
        
        try:
            if выбор == "1":
                print(терминал.показать_меню())
            elif выбор == "2":
                print(терминал.добавить_заказ())
            elif выбор == "3":
                print(терминал.показать_меню())
                пицца_выбор = input("Выберите пиццу (номер): ")
                print(терминал(пицца_выбор))  # Использование __call__
            elif выбор == "4":
                if терминал._Терминал__текущий_заказ:
                    print(терминал._Терминал__текущий_заказ)
                else:
                    print("Заказ не создан")
            elif выбор == "5":
                if терминал._Терминал__текущий_заказ:
                    терминал._Терминал__текущий_заказ._Заказ__статус_заказа = 1
                    print("Заказ подтверждён")
                else:
                    print("Заказ не создан")
            elif выбор == "6":
                print(терминал.оплатить())
            elif выбор == "7":
                if терминал._Терминал__текущий_заказ:
                    print(терминал._Терминал__текущий_заказ.выполнить())
                    терминал.удалить_заказ()
                else:
                    print("Заказ не создан")
            elif выбор == "8":
                print(терминал.удалить_заказ())
            elif выбор == "9":
                print("До свидания!")
                break
            else:
                print("Неверный выбор")
        except Exception as e:
            print(f"Ошибка: {e}")

if __name__ == "__main__":
    main()