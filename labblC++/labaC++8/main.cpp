#include <iostream>
#include <string>
#include <vector>
#include <clocale>
#include <stdexcept>

// Собственные классы исключений
class НедопустимоеИмя : public std::exception {
public:
    const char* what() const noexcept override {
        return "Ошибка: Недопустимое имя (имя не должно быть пустым)!";
    }
};

class СлишкомДлинныйТелефон : public std::exception {
public:
    const char* what() const noexcept override {
        return "Ошибка: Телефон слишком длинный (максимум 15 символов)!";
    }
};

// Шаблонный класс Массив
template <typename T>
class Массив {
private:
    T* элементы;
    size_t размер;
    size_t текущееКоличество;

public:
    Массив(size_t n) : размер(n), текущееКоличество(0) {
        элементы = new T[размер]();
        std::cout << "Создан массив на " << размер << " элементов типа " << typeid(T).name() << std::endl;
    }

    ~Массив() {
        delete[] элементы;
        std::cout << "Массив типа " << typeid(T).name() << " уничтожен" << std::endl;
    }

    bool добавить(const T& элемент) {
        if (текущееКоличество >= размер) {
            throw std::length_error("Массив переполнен!");
        }
        элементы[текущееКоличество] = элемент;
        текущееКоличество++;
        return true;
    }

    T& получить(size_t индекс) {
        if (индекс >= текущееКоличество) {
            throw std::out_of_range("Индекс вне диапазона!");
        }
        return элементы[индекс];
    }

    T min() const {
        if (текущееКоличество == 0) {
            throw std::runtime_error("Массив пуст!");
        }
        T минимальный = элементы[0];
        for (size_t i = 1; i < текущееКоличество; ++i) {
            if (элементы[i] < минимальный) {
                минимальный = элементы[i];
            }
        }
        return минимальный;
    }

    T max() const {
        if (текущееКоличество == 0) {
            throw std::runtime_error("Массив пуст!");
        }
        T максимальный = элементы[0];
        for (size_t i = 1; i < текущееКоличество; ++i) {
            if (элементы[i] > максимальный) {
                максимальный = элементы[i];
            }
        }
        return максимальный;
    }

    size_t getТекущееКоличество() const {
        return текущееКоличество;
    }
};

class Контакт {
protected:
    std::string имя;
    std::string телефон;
    std::string адрес;
    static int количествоОбъектов;

public:
    Контакт() : имя("Неизвестно"), телефон("Неизвестно"), адрес("Неизвестно") {
        количествоОбъектов++;
        std::cout << "Вызван конструктор Контакт без параметров" << std::endl;
    }

    Контакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес)
        : имя(_имя), телефон(_телефон), адрес(_адрес) {
        количествоОбъектов++;
        std::cout << "Вызван конструктор Контакт с параметрами: " << имя << std::endl;
    }

    Контакт(const Контакт& другой)
        : имя(другой.имя + "_копия"), телефон(другой.телефон), адрес(другой.адрес) {
        количествоОбъектов++;
        std::cout << "Вызван конструктор копирования Контакт для: " << имя << std::endl;
    }

    virtual ~Контакт() {
        количествоОбъектов--;
        std::cout << "Вызван деструктор Контакт для: " << имя << std::endl;
    }

    std::string getИмя() const { return имя; }

    virtual void показать() const {
        std::cout << "Имя: " << имя << ", Телефон: " << телефон << ", Адрес: " << адрес << std::endl;
    }

    virtual void ввести() {
        std::cout << "Введите имя: ";
        std::getline(std::cin, имя);
        std::cout << "Введите телефон: ";
        std::getline(std::cin, телефон);
        if (телефон.length() > 15) {
            throw СлишкомДлинныйТелефон();
        }
        std::cout << "Введите адрес: ";
        std::getline(std::cin, адрес);
    }

    virtual void вывестиВсе() const = 0;

    virtual Контакт* clone() const = 0;

    static int getКоличествоОбъектов() {
        return количествоОбъектов;
    }

    bool operator<(const Контакт& другой) const {
        return имя < другой.имя;
    }

    bool operator>(const Контакт& другой) const {
        return имя > другой.имя;
    }
};

int Контакт::количествоОбъектов = 0;

std::ostream& operator<<(std::ostream& os, const Контакт& контакт) {
    контакт.показать();
    return os;
}

class РабочийКонтакт : public Контакт {
protected:
    std::string должность;
    std::string компания;

public:
    РабочийКонтакт() : Контакт(), должность("Неизвестно"), компания("Неизвестно") {
        std::cout << "Вызван конструктор РабочийКонтакт без параметров" << std::endl;
    }

    РабочийКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _должность, const std::string& _компания)
        : Контакт(_имя, _телефон, _адрес), должность(_должность), компания(_компания) {
        std::cout << "Вызван конструктор РабочийКонтакт с параметрами: " << _имя << std::endl;
    }

    РабочийКонтакт(const РабочийКонтакт& другой)
        : Контакт(другой), должность(другой.должность + "_копия"), компания(другой.компания) {
        std::cout << "Вызван конструктор копирования РабочийКонтакт для: " << getИмя() << std::endl;
    }

    ~РабочийКонтакт() override {
        std::cout << "Вызван деструктор РабочийКонтакт для: " << getИмя() << std::endl;
    }

    void показать() const override {
        Контакт::показать();
        std::cout << "Должность: " << должность << ", Компания: " << компания << std::endl;
    }

    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите должность: ";
        std::getline(std::cin, должность);
        std::cout << "Введите компанию: ";
        std::getline(std::cin, компания);
    }

    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные рабочего контакта" << std::endl;
    }

    Контакт* clone() const override {
        return new РабочийКонтакт(*this);
    }
};

std::ostream& operator<<(std::ostream& os, const РабочийКонтакт& контакт) {
    контакт.показать();
    return os;
}

class ЛичныйКонтакт : public Контакт {
protected:
    std::string датаРождения;
    std::string email;

public:
    ЛичныйКонтакт() : Контакт(), датаРождения("Неизвестно"), email("Неизвестно") {
        std::cout << "Вызван конструктор ЛичныйКонтакт без параметров" << std::endl;
    }

    ЛичныйКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _датаРождения, const std::string& _email)
        : Контакт(_имя, _телефон, _адрес), датаРождения(_датаРождения), email(_email) {
        std::cout << "Вызван конструктор ЛичныйКонтакт с параметрами: " << _имя << std::endl;
    }

    ЛичныйКонтакт(const ЛичныйКонтакт& другой)
        : Контакт(другой), датаРождения(другой.датаРождения + "_копия"), email(другой.email) {
        std::cout << "Вызван конструктор копирования ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    ~ЛичныйКонтакт() override {
        std::cout << "Вызван деструктор ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    void показать() const override {
        Контакт::показать();
        std::cout << "Дата рождения: " << датаРождения << ", Email: " << email << std::endl;
    }

    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите дату рождения: ";
        std::getline(std::cin, датаРождения);
        std::cout << "Введите email: ";
        std::getline(std::cin, email);
    }

    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные личного контакта" << std::endl;
    }

    Контакт* clone() const override {
        return new ЛичныйКонтакт(*this);
    }
};

std::ostream& operator<<(std::ostream& os, const ЛичныйКонтакт& контакт) {
    контакт.показать();
    return os;
}

class Справочник {
private:
    std::string название;
    std::string имяВладельца;
    std::vector<Контакт*> контакты;
    static int количествоОбъектовВМассиве;

public:
    Справочник() : название("Без названия"), имяВладельца("Неизвестно") {
        std::cout << "Вызван конструктор Справочник без параметров" << std::endl;
    }

    Справочник(const std::string& _название, const std::string& _имяВладельца)
        : название(_название), имяВладельца(_имяВладельца) {
        std::cout << "Вызван конструктор Справочник с параметрами: " << название << std::endl;
    }

    Справочник(const Справочник& другой)
        : название(другой.название + "_копия"), имяВладельца(другой.имяВладельца) {
        for (const auto* контакт : другой.контакты) {
            контакты.push_back(контакт->clone());
            количествоОбъектовВМассиве++;
        }
        std::cout << "Вызван конструктор копирования Справочник для: " << название << std::endl;
    }

    ~Справочник() {
        for (auto* контакт : контакты) {
            delete контакт;
            количествоОбъектовВМассиве--;
        }
        std::cout << "Вызван деструктор Справочник для: " << название << std::endl;
    }

    std::string getНазвание() const { return название; }
    std::string getИмяВладельца() const { return имяВладельца; }
    std::vector<Контакт*>& getКонтакты() { return контакты; }

    void setНазвание(const std::string& _название) { название = _название; }
    void setИмяВладельца(const std::string& _имяВладельца) { имяВладельца = _имяВладельца; }

    void добавитьКонтакт(Контакт* контакт) {
        // Проверка имени (генерация исключения НедопустимоеИмя)
        if (контакт->getИмя().empty()) {
            throw НедопустимоеИмя();
        }

        // Локальная обработка исключений при добавлении
        try {
            if (контакты.size() >= 5) { // Ограничение на размер
                throw std::length_error("Слишком много контактов в справочнике!");
            }
            контакты.push_back(контакт);
            количествоОбъектовВМассиве++;
            std::cout << "Контакт добавлен: " << контакт->getИмя() << std::endl;
        }
        catch (const std::length_error& e) {
            std::cerr << "Локальная обработка: " << e.what() << std::endl;
            throw; // Переброс исключения на уровень выше
        }
    }

    Справочник& operator+(Контакт* контакт) {
        добавитьКонтакт(контакт);
        return *this;
    }

    Справочник& operator++() {
        добавитьКонтакт(new РабочийКонтакт());
        return *this;
    }

    Справочник operator++(int) {
        Справочник temp = *this;
        добавитьКонтакт(new ЛичныйКонтакт());
        return temp;
    }

    Контакт* operator[](size_t index) {
        if (index >= контакты.size()) {
            throw std::out_of_range("Индекс вне диапазона!");
        }
        return контакты[index];
    }

    void вывестиВсеДанные() const {
        std::cout << "Справочник: " << название << ", Владелец: " << имяВладельца << std::endl;
        std::cout << "Список контактов:" << std::endl;
        for (const auto* контакт : контакты) {
            контакт->вывестиВсе();
            std::cout << "-------------------" << std::endl;
        }
        std::cout << "Всего контактов: " << контакты.size() << std::endl;
    }

    size_t operator()() const {
        return контакты.size();
    }

    static int getКоличествоОбъектовВМассиве() {
        return количествоОбъектовВМассиве;
    }

    friend std::ostream& operator<<(std::ostream& os, const Справочник& справочник);
};

int Справочник::количествоОбъектовВМассиве = 0;

std::ostream& operator<<(std::ostream& os, const Справочник& справочник) {
    справочник.вывестиВсеДанные();
    return os;
}

// Вспомогательная функция для генерации исключений
void сгенерироватьИсключение(int тип) {
    if (тип == 1) {
        throw 42; // Исключение типа int
    }
    else if (тип == 2) {
        throw std::string("Ошибка строки!"); // Исключение типа string
    }
    else if (тип == 3) {
        throw std::invalid_argument("Недопустимый аргумент!");
    }
}

int main() {
    setlocale(LC_ALL, "Russian");

    std::cout << "\n=== Демонстрация обработки исключений ===\n";

    try {
        Справочник справочник("Личный справочник", "Иван Иванов");

        // 1. Добавление контактов (включая возможные исключения)
        std::cout << "\nДобавление контактов в справочник:\n";
        справочник.добавитьКонтакт(new РабочийКонтакт("Анна", "+7-111", "ул. Мира", "Менеджер", "ООО Ромашка"));
        справочник.добавитьКонтакт(new ЛичныйКонтакт("Яна", "+7-222", "ул. Ленина", "01.01.1990", "yana@example.com"));

        // 2. Генерация исключения НедопустимоеИмя
        std::cout << "\nПопытка добавить контакт с пустым именем:\n";
        справочник.добавитьКонтакт(new РабочийКонтакт("", "+7-333", "ул. Советская", "Программист", "ООО Код"));

        // 3. Генерация исключения СлишкомДлинныйТелефон
        std::cout << "\nВвод контакта с длинным телефоном:\n";
        ЛичныйКонтакт контакт;
        контакт.ввести(); // Вводите телефон длиннее 15 символов, например, "+7-999-123-45-67-89"
    }
    catch (const НедопустимоеИмя& e) {
        std::cerr << "Перехвачено исключение НедопустимоеИмя: " << e.what() << std::endl;
    }
    catch (const СлишкомДлинныйТелефон& e) {
        std::cerr << "Перехвачено исключение СлишкомДлинныйТелефон: " << e.what() << std::endl;
    }
    catch (const std::length_error& e) {
        std::cerr << "Перехвачено исключение length_error: " << e.what() << std::endl;
    }
    catch (const std::out_of_range& e) {
        std::cerr << "Перехвачено исключение out_of_range: " << e.what() << std::endl;
    }
    catch (const std::invalid_argument& e) {
        std::cerr << "Перехвачено исключение invalid_argument: " << e.what() << std::endl;
    }
    catch (int e) {
        std::cerr << "Перехвачено исключение типа int: " << e << std::endl;
    }
    catch (const std::string& e) {
        std::cerr << "Перехвачено исключение типа string: " << e << std::endl;
    }
    catch (...) {
        std::cerr << "Перехвачено неизвестное исключение!" << std::endl;
    }

    // Демонстрация генерации различных исключений
    try {
        std::cout << "\nГенерация исключений:\n";
        сгенерироватьИсключение(1); // Генерация int
    }
    catch (int e) {
        std::cerr << "Перехвачено исключение типа int: " << e << std::endl;
    }

    try {
        сгенерироватьИсключение(2); // Генерация string
    }
    catch (const std::string& e) {
        std::cerr << "Перехвачено исключение типа string: " << e << std::endl;
    }

    try {
        сгенерироватьИсключение(3); // Генерация invalid_argument
    }
    catch (const std::invalid_argument& e) {
        std::cerr << "Перехвачено исключение invalid_argument: " << e.what() << std::endl;
    }

    // Демонстрация работы с Массив и перехват исключений
    try {
        std::cout << "\nРабота с Массив:\n";
        Массив<int> массив(2);
        массив.добавить(1);
        массив.добавить(2);
        массив.добавить(3); // Генерация length_error
    }
    catch (const std::length_error& e) {
        std::cerr << "Перехвачено исключение length_error: " << e.what() << std::endl;
    }

    // Демонстрация out_of_range
    try {
        Справочник справочник;
        справочник[0]; // Генерация out_of_range
    }
    catch (const std::out_of_range& e) {
        std::cerr << "Перехвачено исключение out_of_range: " << e.what() << std::endl;
    }

    std::cout << "\n=== Конец программы ===\n";

    return 0;
}