#include <iostream>
#include <string>
#include <vector>
#include <clocale>
#include <fstream>
#include <stdexcept>

// Собственные классы исключений
class НедопустимоеИмя : public std::exception {
public:
    const char* what() const noexcept override {
        return "Ошибка: Недопустимое имя (имя не должно быть пустым)!";
    }
};

class СлишкомДлинныйТелефон : public std::exception {
public:
    const char* what() const noexcept override {
        return "Ошибка: Телефон слишком длинный (максимум 15 символов)!";
    }
};

// Шаблонный класс Массив
template <typename T>
class Массив {
private:
    T* элементы;
    size_t размер;
    size_t текущееКоличество;

public:
    Массив(size_t n) : размер(n), текущееКоличество(0) {
        элементы = new T[размер]();
        std::cout << "Создан массив на " << размер << " элементов типа " << typeid(T).name() << std::endl;
    }

    ~Массив() {
        delete[] элементы;
        std::cout << "Массив типа " << typeid(T).name() << " уничтожен" << std::endl;
    }

    bool добавить(const T& элемент) {
        if (текущееКоличество >= размер) {
            throw std::length_error("Массив переполнен!");
        }
        элементы[текущееКоличество] = элемент;
        текущееКоличество++;
        return true;
    }

    T& получить(size_t индекс) {
        if (индекс >= текущееКоличество) {
            throw std::out_of_range("Индекс вне диапазона!");
        }
        return элементы[индекс];
    }

    T min() const {
        if (текущееКоличество == 0) {
            throw std::runtime_error("Массив пуст!");
        }
        T минимальный = элементы[0];
        for (size_t i = 1; i < текущееКоличество; ++i) {
            if (элементы[i] < минимальный) {
                минимальный = элементы[i];
            }
        }
        return минимальный;
    }

    T max() const {
        if (текущееКоличество == 0) {
            throw std::runtime_error("Массив пуст!");
        }
        T максимальный = элементы[0];
        for (size_t i = 1; i < текущееКоличество; ++i) {
            if (элементы[i] > максимальный) {
                максимальный = элементы[i];
            }
        }
        return максимальный;
    }

    size_t getТекущееКоличество() const {
        return текущееКоличество;
    }
};

class Контакт {
protected:
    std::string имя;
    std::string телефон;
    std::string адрес;
    static int количествоОбъектов;

public:
    Контакт() : имя("Неизвестно"), телефон("Неизвестно"), адрес("Неизвестно") {
        количествоОбъектов++;
        std::cout << "Вызван конструктор Контакт без параметров" << std::endl;
    }

    Контакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес)
        : имя(_имя), телефон(_телефон), адрес(_адрес) {
        количествоОбъектов++;
        std::cout << "Вызван конструктор Контакт с параметрами: " << имя << std::endl;
    }

    Контакт(const Контакт& другой)
        : имя(другой.имя + "_копия"), телефон(другой.телефон), адрес(другой.адрес) {
        количествоОбъектов++;
        std::cout << "Вызван конструктор копирования Контакт для: " << имя << std::endl;
    }

    virtual ~Контакт() {
        количествоОбъектов--;
        std::cout << "Вызван деструктор Контакт для: " << имя << std::endl;
    }

    std::string getИмя() const { return имя; }

    virtual void показать() const {
        std::cout << "Имя: " << имя << ", Телефон: " << телефон << ", Адрес: " << адрес << std::endl;
    }

    virtual void ввести() {
        std::cout << "Введите имя: ";
        std::getline(std::cin, имя);
        std::cout << "Введите телефон: ";
        std::getline(std::cin, телефон);
        if (телефон.length() > 15) {
            throw СлишкомДлинныйТелефон();
        }
        std::cout << "Введите адрес: ";
        std::getline(std::cin, адрес);
    }

    virtual void вывестиВсе() const = 0;

    virtual Контакт* clone() const = 0;

    static int getКоличествоОбъектов() {
        return количествоОбъектов;
    }

    bool operator<(const Контакт& другой) const {
        return имя < другой.имя;
    }

    bool operator>(const Контакт& другой) const {
        return имя > другой.имя;
    }

    // Виртуальный метод для сохранения в файл
    virtual void сохранить(std::ofstream& файл) const {
        файл << имя << "\n" << телефон << "\n" << адрес << "\n";
    }

    // Виртуальный метод для загрузки из файла
    virtual void загрузить(std::ifstream& файл) {
        std::getline(файл, имя);
        std::getline(файл, телефон);
        std::getline(файл, адрес);
        if (телефон.length() > 15) {
            throw СлишкомДлинныйТелефон();
        }
    }

    friend std::ostream& operator<<(std::ostream& os, const Контакт& контакт);
    friend std::istream& operator>>(std::istream& is, Контакт& контакт);
};

int Контакт::количествоОбъектов = 0;

// Глобальный оператор << для Контакт
std::ostream& operator<<(std::ostream& os, const Контакт& контакт) {
    os << "Имя: " << контакт.имя << ", Телефон: " << контакт.телефон << ", Адрес: " << контакт.адрес;
    return os;
}

// Глобальный оператор >> для Контакт
std::istream& operator>>(std::istream& is, Контакт& контакт) {
    std::getline(is, контакт.имя);
    std::getline(is, контакт.телефон);
    if (контакт.телефон.length() > 15) {
        throw СлишкомДлинныйТелефон();
    }
    std::getline(is, контакт.адрес);
    return is;
}

class РабочийКонтакт : public Контакт {
protected:
    std::string должность;
    std::string компания;

public:
    РабочийКонтакт() : Контакт(), должность("Неизвестно"), компания("Неизвестно") {
        std::cout << "Вызван конструктор РабочийКонтакт без параметров" << std::endl;
    }

    РабочийКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _должность, const std::string& _компания)
        : Контакт(_имя, _телефон, _адрес), должность(_должность), компания(_компания) {
        std::cout << "Вызван конструктор РабочийКонтакт с параметрами: " << _имя << std::endl;
    }

    РабочийКонтакт(const РабочийКонтакт& другой)
        : Контакт(другой), должность(другой.должность + "_копия"), компания(другой.компания) {
        std::cout << "Вызван конструктор копирования РабочийКонтакт для: " << getИмя() << std::endl;
    }

    ~РабочийКонтакт() override {
        std::cout << "Вызван деструктор РабочийКонтакт для: " << getИмя() << std::endl;
    }

    void показать() const override {
        Контакт::показать();
        std::cout << "Должность: " << должность << ", Компания: " << компания << std::endl;
    }

    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите должность: ";
        std::getline(std::cin, должность);
        std::cout << "Введите компанию: ";
        std::getline(std::cin, компания);
    }

    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные рабочего контакта" << std::endl;
    }

    Контакт* clone() const override {
        return new РабочийКонтакт(*this);
    }

    void сохранить(std::ofstream& файл) const override {
        Контакт::сохранить(файл);
        файл << должность << "\n" << компания << "\n";
    }

    void загрузить(std::ifstream& файл) override {
        Контакт::загрузить(файл);
        std::getline(файл, должность);
        std::getline(файл, компания);
    }

    // Методы доступа
    void setДолжность(const std::string& д) { должность = д; }
    std::string getДолжность() const { return должность; }
    void setКомпания(const std::string& к) { компания = к; }
    std::string getКомпания() const { return компания; }

    friend std::ostream& operator<<(std::ostream& os, const РабочийКонтакт& контакт);
};

std::ostream& operator<<(std::ostream& os, const РабочийКонтакт& контакт) {
    os << static_cast<const Контакт&>(контакт) << ", Должность: " << контакт.должность << ", Компания: " << контакт.компания;
    return os;
}

class ЛичныйКонтакт : public Контакт {
protected:
    std::string датаРождения;
    std::string email;

public:
    ЛичныйКонтакт() : Контакт(), датаРождения("Неизвестно"), email("Неизвестно") {
        std::cout << "Вызван конструктор ЛичныйКонтакт без параметров" << std::endl;
    }

    ЛичныйКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _датаРождения, const std::string& _email)
        : Контакт(_имя, _телефон, _адрес), датаРождения(_датаРождения), email(_email) {
        std::cout << "Вызван конструктор ЛичныйКонтакт с параметрами: " << _имя << std::endl;
    }

    ЛичныйКонтакт(const ЛичныйКонтакт& другой)
        : Контакт(другой), датаРождения(другой.датаРождения + "_копия"), email(другой.email) {
        std::cout << "Вызван конструктор копирования ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    ~ЛичныйКонтакт() override {
        std::cout << "Вызван деструктор ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    void показать() const override {
        Контакт::показать();
        std::cout << "Дата рождения: " << датаРождения << ", Email: " << email << std::endl;
    }

    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите дату рождения: ";
        std::getline(std::cin, датаРождения);
        std::cout << "Введите email: ";
        std::getline(std::cin, email);
    }

    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные личного контакта" << std::endl;
    }

    Контакт* clone() const override {
        return new ЛичныйКонтакт(*this);
    }

    void сохранить(std::ofstream& файл) const override {
        Контакт::сохранить(файл);
        файл << датаРождения << "\n" << email << "\n";
    }

    void загрузить(std::ifstream& файл) override {
        Контакт::загрузить(файл);
        std::getline(файл, датаРождения);
        std::getline(файл, email);
    }

    // Методы доступа
    void setДатаРождения(const std::string& д) { датаРождения = д; }
    std::string getДатаРождения() const { return датаРождения; }
    void setEmail(const std::string& е) { email = е; }
    std::string getEmail() const { return email; }

    friend std::ostream& operator<<(std::ostream& os, const ЛичныйКонтакт& контакт);
};

std::ostream& operator<<(std::ostream& os, const ЛичныйКонтакт& контакт) {
    os << static_cast<const Контакт&>(контакт) << ", Дата рождения: " << контакт.датаРождения << ", Email: " << контакт.email;
    return os;
}

class Справочник {
private:
    std::string название;
    std::string имяВладельца;
    std::vector<Контакт*> контакты;
    static int количествоОбъектовВМассиве;

public:
    Справочник() : название("Без названия"), имяВладельца("Неизвестно") {
        std::cout << "Вызван конструктор Справочник без параметров" << std::endl;
    }

    Справочник(const std::string& _название, const std::string& _имяВладельца)
        : название(_название), имяВладельца(_имяВладельца) {
        std::cout << "Вызван конструктор Справочник с параметрами: " << название << std::endl;
    }

    Справочник(const Справочник& другой)
        : название(другой.название + "_копия"), имяВладельца(другой.имяВладельца) {
        for (const auto* контакт : другой.контакты) {
            контакты.push_back(контакт->clone());
            количествоОбъектовВМассиве++;
        }
        std::cout << "Вызван конструктор копирования Справочник для: " << название << std::endl;
    }

    ~Справочник() {
        for (auto* контакт : контакты) {
            delete контакт;
            количествоОбъектовВМассиве--;
        }
        std::cout << "Вызван деструктор Справочник для: " << название << std::endl;
    }

    std::string getНазвание() const { return название; }
    std::string getИмяВладельца() const { return имяВладельца; }
    std::vector<Контакт*>& getКонтакты() { return контакты; }

    void setНазвание(const std::string& _название) { название = _название; }
    void setИмяВладельца(const std::string& _имяВладельца) { имяВладельца = _имяВладельца; }

    void добавитьКонтакт(Контакт* контакт) {
        if (контакт->getИмя().empty()) {
            throw НедопустимоеИмя();
        }
        if (контакты.size() >= 5) {
            throw std::length_error("Слишком много контактов в справочнике!");
        }
        контакты.push_back(контакт);
        количествоОбъектовВМассиве++;
        std::cout << "Контакт добавлен: " << контакт->getИмя() << std::endl;
    }

    Справочник& operator+(Контакт* контакт) {
        добавитьКонтакт(контакт);
        return *this;
    }

    Справочник& operator++() {
        добавитьКонтакт(new РабочийКонтакт());
        return *this;
    }

    Справочник operator++(int) {
        Справочник temp = *this;
        добавитьКонтакт(new ЛичныйКонтакт());
        return temp;
    }

    Контакт* operator[](size_t index) {
        if (index >= контакты.size()) {
            throw std::out_of_range("Индекс вне диапазона!");
        }
        return контакты[index];
    }

    void вывестиВсеДанные() const {
        std::cout << "Справочник: " << название << ", Владелец: " << имяВладельца << std::endl;
        std::cout << "Список контактов:" << std::endl;
        for (const auto* контакт : контакты) {
            контакт->вывестиВсе();
            std::cout << "-------------------" << std::endl;
        }
        std::cout << "Всего контактов: " << контакты.size() << std::endl;
    }

    size_t operator()() const {
        return контакты.size();
    }

    static int getКоличествоОбъектовВМассиве() {
        return количествоОбъектовВМассиве;
    }

    void сохранитьВФайл(const std::string& имяФайла) const {
        std::ofstream файл(имяФайла);
        if (!файл.is_open()) {
            throw std::runtime_error("Не удалось открыть файл для записи!");
        }
        файл << название << "\n" << имяВладельца << "\n" << контакты.size() << "\n";
        for (const auto* контакт : контакты) {
            if (dynamic_cast<const РабочийКонтакт*>(контакт)) {
                файл << "Рабочий\n";
            }
            else if (dynamic_cast<const ЛичныйКонтакт*>(контакт)) {
                файл << "Личный\n";
            }
            контакт->сохранить(файл);
        }
        файл.close();
        std::cout << "Данные сохранены в файл " << имяФайла << std::endl;
    }

    void загрузитьИзФайла(const std::string& имяФайла) {
        std::ifstream файл(имяФайла);
        if (!файл.is_open()) {
            throw std::runtime_error("Не удалось открыть файл для чтения!");
        }
        for (auto* контакт : контакты) {
            delete контакт;
        }
        контакты.clear();
        количествоОбъектовВМассиве = 0;

        std::getline(файл, название);
        std::getline(файл, имяВладельца);
        size_t размер;
        файл >> размер;
        файл.ignore(); // Игнорируем символ новой строки
        for (size_t i = 0; i < размер; ++i) {
            std::string тип;
            std::getline(файл, тип);
            Контакт* контакт = nullptr;
            if (тип == "Рабочий") {
                контакт = new РабочийКонтакт();
            }
            else if (тип == "Личный") {
                контакт = new ЛичныйКонтакт();
            }
            else {
                throw std::runtime_error("Неизвестный тип контакта в файле!");
            }
            контакт->загрузить(файл);
            if (dynamic_cast<РабочийКонтакт*>(контакт)) {
                РабочийКонтакт* раб = dynamic_cast<РабочийКонтакт*>(контакт);
                std::string должность, компания;
                std::getline(файл, должность);
                std::getline(файл, компания);
                раб->setДолжность(должность);
                раб->setКомпания(компания);
            }
            else if (dynamic_cast<ЛичныйКонтакт*>(контакт)) {
                ЛичныйКонтакт* лич = dynamic_cast<ЛичныйКонтакт*>(контакт);
                std::string датаРождения, email;
                std::getline(файл, датаРождения);
                std::getline(файл, email);
                лич->setДатаРождения(датаРождения);
                лич->setEmail(email);
            }
            контакты.push_back(контакт);
            количествоОбъектовВМассиве++;
        }
        файл.close();
        std::cout << "Данные загружены из файла " << имяФайла << std::endl;
    }

    friend std::ostream& operator<<(std::ostream& os, const Справочник& справочник);
};

int Справочник::количествоОбъектовВМассиве = 0;

std::ostream& operator<<(std::ostream& os, const Справочник& справочник) {
    справочник.вывестиВсеДанные();
    return os;
}

int main() {
    setlocale(LC_ALL, "Russian");

    std::cout << "\n=== Демонстрация работы с файлами и операторами ===\n";

    try {
        // Создание и заполнение справочника
        Справочник справочник("Личный справочник", "Иван Иванов");

        // Использование оператора >> для ввода контакта
        std::cout << "\nВведите данные нового рабочего контакта (имя, телефон, адрес):\n";
        РабочийКонтакт* новыйРаб = new РабочийКонтакт();
        std::cin >> *новыйРаб;
        std::cout << "Введите должность: ";
        std::string должность;
        std::getline(std::cin >> std::ws, должность); // Очистка буфера и чтение
        новыйРаб->setДолжность(должность);
        std::cout << "Введите компанию: ";
        std::string компания;
        std::getline(std::cin, компания);
        новыйРаб->setКомпания(компания);
        справочник.добавитьКонтакт(новыйРаб);

        // Добавление другого контакта
        справочник + new ЛичныйКонтакт("Яна", "+7-222", "ул. Ленина", "01.01.1990", "yana@example.com");

        // Вывод с помощью оператора <<
        std::cout << "\nТекущий справочник:\n" << справочник;

        // Сохранение в файл
        справочник.сохранитьВФайл("phonebook.txt");

        // Создание нового справочника и загрузка из файла
        Справочник новыйСправочник;
        новыйСправочник.загрузитьИзФайла("phonebook.txt");

        std::cout << "\nСправочник после загрузки из файла:\n" << новыйСправочник;
    }
    catch (const std::exception& e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }

    std::cout << "\n=== Конец программы ===\n";

    return 0;
}