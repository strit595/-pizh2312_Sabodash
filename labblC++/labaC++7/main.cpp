#include <iostream>
#include <string>
#include <vector>
#include <clocale>

// Шаблонный класс Массив
template <typename T>
class Массив {
private:
    T* элементы;
    size_t размер;
    size_t текущееКоличество;

public:
    // Конструктор с параметром n (размер массива)
    Массив(size_t n) : размер(n), текущееКоличество(0) {
        элементы = new T[размер]();
        std::cout << "Создан массив на " << размер << " элементов типа " << typeid(T).name() << std::endl;
    }

    // Деструктор
    ~Массив() {
        delete[] элементы;
        std::cout << "Массив типа " << typeid(T).name() << " уничтожен" << std::endl;
    }

    // Метод добавления элемента
    bool добавить(const T& элемент) {
        if (текущееКоличество < размер) {
            элементы[текущееКоличество] = элемент;
            текущееКоличество++;
            return true;
        }
        std::cerr << "Ошибка: Массив полон!" << std::endl;
        return false;
    }

    // Метод получения элемента по индексу
    T& получить(size_t индекс) {
        if (индекс >= текущееКоличество) {
            std::cerr << "Ошибка: Индекс вне диапазона!" << std::endl;
            throw std::out_of_range("Индекс вне диапазона");
        }
        return элементы[индекс];
    }

    // Функция нахождения минимального элемента
    T min() const {
        if (текущееКоличество == 0) {
            std::cerr << "Ошибка: Массив пуст!" << std::endl;
            throw std::runtime_error("Массив пуст");
        }
        T минимальный = элементы[0];
        for (size_t i = 1; i < текущееКоличество; ++i) {
            if (элементы[i] < минимальный) {
                минимальный = элементы[i];
            }
        }
        return минимальный;
    }

    // Функция нахождения максимального элемента
    T max() const {
        if (текущееКоличество == 0) {
            std::cerr << "Ошибка: Массив пуст!" << std::endl;
            throw std::runtime_error("Массив пуст");
        }
        T максимальный = элементы[0];
        for (size_t i = 1; i < текущееКоличество; ++i) {
            if (элементы[i] > максимальный) {
                максимальный = элементы[i];
            }
        }
        return максимальный;
    }

    // Метод для получения текущего количества элементов
    size_t getТекущееКоличество() const {
        return текущееКоличество;
    }
};

class Контакт {
protected:
    std::string имя;
    std::string телефон;
    std::string адрес;
    static int количествоОбъектов; // Статический счётчик объектов

public:
    // Конструктор без параметров
    Контакт() : имя("Неизвестно"), телефон("Неизвестно"), адрес("Неизвестно") {
        количествоОбъектов++;
        std::cout << "Вызван конструктор Контакт без параметров" << std::endl;
    }

    // Конструктор с параметрами
    Контакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес)
        : имя(_имя), телефон(_телефон), адрес(_адрес) {
        количествоОбъектов++;
        std::cout << "Вызван конструктор Контакт с параметрами: " << имя << std::endl;
    }

    // Конструктор копирования
    Контакт(const Контакт& другой)
        : имя(другой.имя + "_копия"), телефон(другой.телефон), адрес(другой.адрес) {
        количествоОбъектов++;
        std::cout << "Вызван конструктор копирования Контакт для: " << имя << std::endl;
    }

    // Виртуальный деструктор
    virtual ~Контакт() {
        количествоОбъектов--;
        std::cout << "Вызван деструктор Контакт для: " << имя << std::endl;
    }

    // Геттер для имени
    std::string getИмя() const { return имя; }

    // Виртуальный метод вывода
    virtual void показать() const {
        std::cout << "Имя: " << имя << ", Телефон: " << телефон << ", Адрес: " << адрес << std::endl;
    }

    // Метод ввода данных
    virtual void ввести() {
        std::cout << "Введите имя: ";
        std::getline(std::cin, имя);
        std::cout << "Введите телефон: ";
        std::getline(std::cin, телефон);
        std::cout << "Введите адрес: ";
        std::getline(std::cin, адрес);
    }

    // Чисто виртуальная функция
    virtual void вывестиВсе() const = 0;

    // Чисто виртуальный метод клонирования
    virtual Контакт* clone() const = 0;

    // Статический метод для получения количества объектов
    static int getКоличествоОбъектов() {
        return количествоОбъектов;
    }

    // Перегрузка операторов сравнения по полю имя
    bool operator<(const Контакт& другой) const {
        return имя < другой.имя;
    }

    bool operator>(const Контакт& другой) const {
        return имя > другой.имя;
    }
};

// Инициализация статического члена
int Контакт::количествоОбъектов = 0;

// Перегрузка оператора << для Контакт
std::ostream& operator<<(std::ostream& os, const Контакт& контакт) {
    контакт.показать();
    return os;
}

class РабочийКонтакт : public Контакт {
protected:
    std::string должность;
    std::string компания;

public:
    // Конструктор без параметров
    РабочийКонтакт() : Контакт(), должность("Неизвестно"), компания("Неизвестно") {
        std::cout << "Вызван конструктор РабочийКонтакт без параметров" << std::endl;
    }

    // Конструктор с параметрами
    РабочийКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _должность, const std::string& _компания)
        : Контакт(_имя, _телефон, _адрес), должность(_должность), компания(_компания) {
        std::cout << "Вызван конструктор РабочийКонтакт с параметрами: " << _имя << std::endl;
    }

    // Конструктор копирования
    РабочийКонтакт(const РабочийКонтакт& другой)
        : Контакт(другой), должность(другой.должность + "_копия"), компания(другой.компания) {
        std::cout << "Вызван конструктор копирования РабочийКонтакт для: " << getИмя() << std::endl;
    }

    // Деструктор
    ~РабочийКонтакт() override {
        std::cout << "Вызван деструктор РабочийКонтакт для: " << getИмя() << std::endl;
    }

    // Переопределённый метод вывода
    void показать() const override {
        Контакт::показать();
        std::cout << "Должность: " << должность << ", Компания: " << компания << std::endl;
    }

    // Метод ввода данных
    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите должность: ";
        std::getline(std::cin, должность);
        std::cout << "Введите компанию: ";
        std::getline(std::cin, компания);
    }

    // Перегрузка чисто виртуальной функции
    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные рабочего контакта" << std::endl;
    }

    // Реализация метода clone
    Контакт* clone() const override {
        return new РабочийКонтакт(*this);
    }
};

// Перегрузка оператора << для РабочийКонтакт
std::ostream& operator<<(std::ostream& os, const РабочийКонтакт& контакт) {
    контакт.показать();
    return os;
}

class ЛичныйКонтакт : public Контакт {
protected:
    std::string датаРождения;
    std::string email;

public:
    // Конструктор без параметров
    ЛичныйКонтакт() : Контакт(), датаРождения("Неизвестно"), email("Неизвестно") {
        std::cout << "Вызван конструктор ЛичныйКонтакт без параметров" << std::endl;
    }

    // Конструктор с параметрами
    ЛичныйКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _датаРождения, const std::string& _email)
        : Контакт(_имя, _телефон, _адрес), датаРождения(_датаРождения), email(_email) {
        std::cout << "Вызван конструктор ЛичныйКонтакт с параметрами: " << _имя << std::endl;
    }

    // Конструктор копирования
    ЛичныйКонтакт(const ЛичныйКонтакт& другой)
        : Контакт(другой), датаРождения(другой.датаРождения + "_копия"), email(другой.email) {
        std::cout << "Вызван конструктор копирования ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    // Деструктор
    ~ЛичныйКонтакт() override {
        std::cout << "Вызван деструктор ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    // Переопределённый метод вывода
    void показать() const override {
        Контакт::показать();
        std::cout << "Дата рождения: " << датаРождения << ", Email: " << email << std::endl;
    }

    // Метод ввода данных
    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите дату рождения: ";
        std::getline(std::cin, датаРождения);
        std::cout << "Введите email: ";
        std::getline(std::cin, email);
    }

    // Перегрузка чисто виртуальной функции
    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные личного контакта" << std::endl;
    }

    // Реализация метода clone
    Контакт* clone() const override {
        return new ЛичныйКонтакт(*this);
    }
};

// Перегрузка оператора << для ЛичныйКонтакт
std::ostream& operator<<(std::ostream& os, const ЛичныйКонтакт& контакт) {
    контакт.показать();
    return os;
}

class Справочник {
private:
    std::string название;
    std::string имяВладельца;
    std::vector<Контакт*> контакты;
    static int количествоОбъектовВМассиве; // Статический счётчик объектов в массиве

public:
    // Конструктор без параметров
    Справочник() : название("Без названия"), имяВладельца("Неизвестно") {
        std::cout << "Вызван конструктор Справочник без параметров" << std::endl;
    }

    // Конструктор с параметрами
    Справочник(const std::string& _название, const std::string& _имяВладельца)
        : название(_название), имяВладельца(_имяВладельца) {
        std::cout << "Вызван конструктор Справочник с параметрами: " << название << std::endl;
    }

    // Конструктор копирования
    Справочник(const Справочник& другой)
        : название(другой.название + "_копия"), имяВладельца(другой.имяВладельца) {
        for (const auto* контакт : другой.контакты) {
            контакты.push_back(контакт->clone());
            количествоОбъектовВМассиве++;
        }
        std::cout << "Вызван конструктор копирования Справочник для: " << название << std::endl;
    }

    // Деструктор
    ~Справочник() {
        for (auto* контакт : контакты) {
            delete контакт;
            количествоОбъектовВМассиве--;
        }
        std::cout << "Вызван деструктор Справочник для: " << название << std::endl;
    }

    // Геттеры
    std::string getНазвание() const { return название; }
    std::string getИмяВладельца() const { return имяВладельца; }
    std::vector<Контакт*>& getКонтакты() { return контакты; }

    // Сеттеры
    void setНазвание(const std::string& _название) { название = _название; }
    void setИмяВладельца(const std::string& _имяВладельца) { имяВладельца = _имяВладельца; }

    // Добавление контакта
    void добавитьКонтакт(Контакт* контакт) {
        контакты.push_back(контакт);
        количествоОбъектовВМассиве++;
        std::cout << "Контакт добавлен: " << контакт->getИмя() << std::endl;
    }

    // Оператор + для добавления объекта наследника
    Справочник& operator+(Контакт* контакт) {
        добавитьКонтакт(контакт);
        return *this;
    }

    // Префиксный оператор ++ (добавляет РабочийКонтакт по умолчанию)
    Справочник& operator++() {
        добавитьКонтакт(new РабочийКонтакт());
        return *this;
    }

    // Постфиксный оператор ++ (добавляет ЛичныйКонтакт по умолчанию)
    Справочник operator++(int) {
        Справочник temp = *this;
        добавитьКонтакт(new ЛичныйКонтакт());
        return temp;
    }

    // Оператор [] для доступа к элементу массива
    Контакт* operator[](size_t index) {
        if (index >= контакты.size()) {
            std::cerr << "Ошибка: Индекс вне диапазона!" << std::endl;
            return nullptr;
        }
        return контакты[index];
    }

    // Метод вывода всех данных
    void вывестиВсеДанные() const {
        std::cout << "Справочник: " << название << ", Владелец: " << имяВладельца << std::endl;
        std::cout << "Список контактов:" << std::endl;
        for (const auto* контакт : контакты) {
            контакт->вывестиВсе();
            std::cout << "-------------------" << std::endl;
        }
        std::cout << "Всего контактов: " << контакты.size() << std::endl;
    }

    // Перегрузка оператора ()
    size_t operator()() const {
        return контакты.size();
    }

    // Статический метод для получения количества объектов в массиве
    static int getКоличествоОбъектовВМассиве() {
        return количествоОбъектовВМассиве;
    }

    // Дружественная функция для оператора <<
    friend std::ostream& operator<<(std::ostream& os, const Справочник& справочник);
};

// Инициализация статического члена
int Справочник::количествоОбъектовВМассиве = 0;

// Глобальный оператор << для Справочник
std::ostream& operator<<(std::ostream& os, const Справочник& справочник) {
    справочник.вывестиВсеДанные();
    return os;
}

int main() {
    // Установка русской локали
    setlocale(LC_ALL, "Russian");

    std::cout << "\n=== Демонстрация шаблонного класса Массив ===\n";

    // 1. Массив типа int
    std::cout << "\nМассив типа int:\n";
    Массив<int> массивInt(5);
    массивInt.добавить(10);
    массивInt.добавить(3);
    массивInt.добавить(15);
    std::cout << "Минимальное значение: " << массивInt.min() << std::endl;
    std::cout << "Максимальное значение: " << массивInt.max() << std::endl;
    std::cout << "Элемент с индексом 1: " << массивInt.получить(1) << std::endl;

    // 2. Массив типа char
    std::cout << "\nМассив типа char:\n";
    Массив<char> массивChar(4);
    массивChar.добавить('b');
    массивChar.добавить('x');
    массивChar.добавить('a');
    std::cout << "Минимальное значение: " << массивChar.min() << std::endl;
    std::cout << "Максимальное значение: " << массивChar.max() << std::endl;
    std::cout << "Элемент с индексом 0: " << массивChar.получить(0) << std::endl;

    // 3. Массив указателей на Контакт
    std::cout << "\nМассив указателей на Контакт:\n";
    Массив<Контакт*> массивКонтактов(3);
    Контакт* контакт1 = new РабочийКонтакт("Анна", "+7-111", "ул. Мира", "Менеджер", "ООО Ромашка");
    Контакт* контакт2 = new ЛичныйКонтакт("Яна", "+7-222", "ул. Ленина", "01.01.1990", "yana@example.com");
    Контакт* контакт3 = new РабочийКонтакт("Борис", "+7-333", "ул. Советская", "Программист", "ООО Код");
    массивКонтактов.добавить(контакт1);
    массивКонтактов.добавить(контакт2);
    массивКонтактов.добавить(контакт3);
    std::cout << "Минимальный контакт (по имени):\n";
    массивКонтактов.min()->вывестиВсе();
    std::cout << "Максимальный контакт (по имени):\n";
    массивКонтактов.max()->вывестиВсе();
    std::cout << "Контакт с индексом 1:\n";
    массивКонтактов.получить(1)->вывестиВсе();

    // 4. Массив типа РабочийКонтакт
    std::cout << "\nМассив типа РабочийКонтакт:\n";
    Массив<РабочийКонтакт> массивРабочих(3);
    массивРабочих.добавить(РабочийКонтакт("Виктор", "+7-444", "ул. Пушкина", "Инженер", "ООО Техно"));
    массивРабочих.добавить(РабочийКонтакт("Елена", "+7-555", "ул. Гагарина", "Бухгалтер", "ООО Финансы"));
    массивРабочих.добавить(РабочийКонтакт("Дмитрий", "+7-666", "ул. Чехова", "Дизайнер", "ООО Арт"));
    std::cout << "Минимальный РабочийКонтакт (по имени):\n";
    массивРабочих.min().вывестиВсе();
    std::cout << "Максимальный РабочийКонтакт (по имени):\n";
    массивРабочих.max().вывестиВсе();
    std::cout << "РабочийКонтакт с индексом 2:\n";
    массивРабочих.получить(2).вывестиВсе();

    // 5. Массив типа ЛичныйКонтакт
    std::cout << "\nМассив типа ЛичныйКонтакт:\n";
    Массив<ЛичныйКонтакт> массивЛичных(3);
    массивЛичных.добавить(ЛичныйКонтакт("Ксения", "+7-777", "ул. Садовая", "15.05.1995", "ksenia@example.com"));
    массивЛичных.добавить(ЛичныйКонтакт("Михаил", "+7-888", "ул. Солнечная", "20.10.1980", "mikhail@example.com"));
    массивЛичных.добавить(ЛичныйКонтакт("Ольга", "+7-999", "ул. Цветочная", "10.03.1992", "olga@example.com"));
    std::cout << "Минимальный ЛичныйКонтакт (по имени):\n";
    массивЛичных.min().вывестиВсе();
    std::cout << "Максимальный ЛичныйКонтакт (по имени):\n";
    массивЛичных.max().вывестиВсе();
    std::cout << "ЛичныйКонтакт с индексом 0:\n";
    массивЛичных.получить(0).вывестиВсе();

    // Очистка памяти для указателей на Контакт
    for (size_t i = 0; i < массивКонтактов.getТекущееКоличество(); ++i) {
        delete массивКонтактов.получить(i);
    }

    std::cout << "\n=== Конец программы ===\n";

    return 0;
}