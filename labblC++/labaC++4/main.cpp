#include <iostream>
#include <string>
#include <vector>
#include <clocale>

class Контакт {
protected:
    std::string имя;
    std::string телефон;
    std::string адрес;

public:
    // Конструктор без параметров
    Контакт() : имя("Неизвестно"), телефон("Неизвестно"), адрес("Неизвестно") {
        std::cout << "Вызван конструктор Контакт без параметров" << std::endl;
    }

    // Конструктор с параметрами
    Контакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес)
        : имя(_имя), телефон(_телефон), адрес(_адрес) {
        std::cout << "Вызван конструктор Контакт с параметрами: " << имя << std::endl;
    }

    // Конструктор копирования
    Контакт(const Контакт& другой)
        : имя(другой.имя + "_копия"), телефон(другой.телефон), адрес(другой.адрес) {
        std::cout << "Вызван конструктор копирования Контакт для: " << имя << std::endl;
    }

    // Виртуальный деструктор
    virtual ~Контакт() {
        std::cout << "Вызван деструктор Контакт для: " << имя << std::endl;
    }

    // Геттер для имени
    std::string getИмя() const { return имя; }

    // Виртуальный метод вывода
    virtual void показать() const {
        std::cout << "Имя: " << имя << ", Телефон: " << телефон << ", Адрес: " << адрес << std::endl;
    }

    // Метод ввода данных
    virtual void ввести() {
        std::cout << "Введите имя: ";
        std::getline(std::cin, имя);
        std::cout << "Введите телефон: ";
        std::getline(std::cin, телефон);
        std::cout << "Введите адрес: ";
        std::getline(std::cin, адрес);
    }

    // Чисто виртуальная функция
    virtual void вывестиВсе() const = 0;

    // Чисто виртуальный метод клонирования
    virtual Контакт* clone() const = 0;
};

// Перегрузка оператора << для Контакт
std::ostream& operator<<(std::ostream& os, const Контакт& контакт) {
    контакт.показать();
    return os;
}

class РабочийКонтакт : public Контакт {
protected:
    std::string должность;
    std::string компания;

public:
    // Конструктор без параметров
    РабочийКонтакт() : Контакт(), должность("Неизвестно"), компания("Неизвестно") {
        std::cout << "Вызван конструктор РабочийКонтакт без параметров" << std::endl;
    }

    // Конструктор с параметрами
    РабочийКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _должность, const std::string& _компания)
        : Контакт(_имя, _телефон, _адрес), должность(_должность), компания(_компания) {
        std::cout << "Вызван конструктор РабочийКонтакт с параметрами: " << _имя << std::endl;
    }

    // Конструктор копирования
    РабочийКонтакт(const РабочийКонтакт& другой)
        : Контакт(другой), должность(другой.должность + "_копия"), компания(другой.компания) {
        std::cout << "Вызван конструктор копирования РабочийКонтакт для: " << getИмя() << std::endl;
    }

    // Деструктор
    ~РабочийКонтакт() override {
        std::cout << "Вызван деструктор РабочийКонтакт для: " << getИмя() << std::endl;
    }

    // Переопределённый метод вывода
    void показать() const override {
        Контакт::показать();
        std::cout << "Должность: " << должность << ", Компания: " << компания << std::endl;
    }

    // Метод ввода данных
    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите должность: ";
        std::getline(std::cin, должность);
        std::cout << "Введите компанию: ";
        std::getline(std::cin, компания);
    }

    // Перегрузка чисто виртуальной функции
    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные рабочего контакта" << std::endl;
    }

    // Реализация метода clone
    Контакт* clone() const override {
        return new РабочийКонтакт(*this);
    }
};

// Перегрузка оператора << для РабочийКонтакт
std::ostream& operator<<(std::ostream& os, const РабочийКонтакт& контакт) {
    контакт.показать();
    return os;
}

class ЛичныйКонтакт : public Контакт {
protected:
    std::string датаРождения;
    std::string email;

public:
    // Конструктор без параметров
    ЛичныйКонтакт() : Контакт(), датаРождения("Неизвестно"), email("Неизвестно") {
        std::cout << "Вызван конструктор ЛичныйКонтакт без параметров" << std::endl;
    }

    // Конструктор с параметрами
    ЛичныйКонтакт(const std::string& _имя, const std::string& _телефон, const std::string& _адрес,
        const std::string& _датаРождения, const std::string& _email)
        : Контакт(_имя, _телефон, _адрес), датаРождения(_датаРождения), email(_email) {
        std::cout << "Вызван конструктор ЛичныйКонтакт с параметрами: " << _имя << std::endl;
    }

    // Конструктор копирования
    ЛичныйКонтакт(const ЛичныйКонтакт& другой)
        : Контакт(другой), датаРождения(другой.датаРождения + "_копия"), email(другой.email) {
        std::cout << "Вызван конструктор копирования ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    // Деструктор
    ~ЛичныйКонтакт() override {
        std::cout << "Вызван деструктор ЛичныйКонтакт для: " << getИмя() << std::endl;
    }

    // Переопределённый метод вывода
    void показать() const override {
        Контакт::показать();
        std::cout << "Дата рождения: " << датаРождения << ", Email: " << email << std::endl;
    }

    // Метод ввода данных
    void ввести() override {
        Контакт::ввести();
        std::cout << "Введите дату рождения: ";
        std::getline(std::cin, датаРождения);
        std::cout << "Введите email: ";
        std::getline(std::cin, email);
    }

    // Перегрузка чисто виртуальной функции
    void вывестиВсе() const override {
        показать();
        std::cout << "Полные данные личного контакта" << std::endl;
    }

    // Реализация метода clone
    Контакт* clone() const override {
        return new ЛичныйКонтакт(*this);
    }
};

// Перегрузка оператора << для ЛичныйКонтакт
std::ostream& operator<<(std::ostream& os, const ЛичныйКонтакт& контакт) {
    контакт.показать();
    return os;
}

class Справочник {
private:
    std::string название;
    std::string имяВладельца;
    std::vector<Контакт*> контакты;

public:
    // Конструктор без параметров
    Справочник() : название("Без названия"), имяВладельца("Неизвестно") {
        std::cout << "Вызван конструктор Справочник без параметров" << std::endl;
    }

    // Конструктор с параметрами
    Справочник(const std::string& _название, const std::string& _имяВладельца)
        : название(_название), имяВладельца(_имяВладельца) {
        std::cout << "Вызван конструктор Справочник с параметрами: " << название << std::endl;
    }

    // Конструктор копирования
    Справочник(const Справочник& другой)
        : название(другой.название + "_копия"), имяВладельца(другой.имяВладельца) {
        for (const auto* контакт : другой.контакты) {
            контакты.push_back(контакт->clone());
        }
        std::cout << "Вызван конструктор копирования Справочник для: " << название << std::endl;
    }

    // Деструктор
    ~Справочник() {
        for (auto* контакт : контакты) {
            delete контакт;
        }
        std::cout << "Вызван деструктор Справочник для: " << название << std::endl;
    }

    // Геттеры
    std::string getНазвание() const { return название; }
    std::string getИмяВладельца() const { return имяВладельца; }
    std::vector<Контакт*>& getКонтакты() { return контакты; }

    // Сеттеры
    void setНазвание(const std::string& _название) { название = _название; }
    void setИмяВладельца(const std::string& _имяВладельца) { имяВладельца = _имяВладельца; }

    // Добавление контакта
    void добавитьКонтакт(Контакт* контакт) {
        контакты.push_back(контакт);
        std::cout << "Контакт добавлен: " << контакт->getИмя() << std::endl;
    }

    // Метод вывода всех данных
    void вывестиВсеДанные() const {
        std::cout << "Справочник: " << название << ", Владелец: " << имяВладельца << std::endl;
        std::cout << "Список контактов:" << std::endl;
        for (const auto* контакт : контакты) {
            контакт->вывестиВсе();
            std::cout << "-------------------" << std::endl;
        }
        std::cout << "Всего контактов: " << контакты.size() << std::endl;
    }

    // Перегрузка оператора ()
    size_t operator()() const {
        return контакты.size();
    }
};

int main() {
    // Установка русской локали
    setlocale(LC_ALL, "Russian");

    std::cout << "\n=== Массив типа Контакт* ===\n";

    // Создание массива указателей на базовый класс
    Контакт* массивКонтактов[3];
    массивКонтактов[0] = new РабочийКонтакт("Иван", "+7-999-234-56-78", "ул. Мира, 10", "Менеджер", "ООО Ромашка");
    массивКонтактов[1] = new ЛичныйКонтакт("Мария", "+7-999-345-67-89", "пр. Победы, 5", "01.01.1990", "maria@example.com");
    массивКонтактов[2] = new РабочийКонтакт("Ольга", "+7-999-567-89-01", "ул. Центральная, 20", "Программист", "ООО Код");

    // Цикл вывода данных с вызовом вывестиВсе()
    for (int i = 0; i < 3; ++i) {
        массивКонтактов[i]->вывестиВсе();
        std::cout << "-------------------" << std::endl;
    }

    // Освобождение памяти
    for (int i = 0; i < 3; ++i) {
        delete массивКонтактов[i];
    }

    std::cout << "\n=== Работа с объектом Справочник ===\n";

    // Создание объекта Справочник
    Справочник справочник("Личный справочник", "Иван Иванов");
    справочник.добавитьКонтакт(new РабочийКонтакт("Петр", "+7-999-456-78-90", "ул. Советская, 15", "Инженер", "ООО Техно"));
    справочник.добавитьКонтакт(new ЛичныйКонтакт("Анна", "+7-999-678-90-12", "пр. Свободы, 25", "15.05.1985", "anna@example.com"));

    // Вывод всех данных
    справочник.вывестиВсеДанные();

    std::cout << "\n=== Конец программы ===\n";

    return 0;
}